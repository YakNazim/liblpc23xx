ARM GAS  lpc23xx-mutex/lpc23xx-mutex.s 			page 1


   1              	
   2              	/*
   3              	 * lpc23xx-mutex.s
   4              	 **
   5              	 * Tue 14 June 2011 16:46:03 (PDT)
   6              	 * initial experiment using SWP instruction and building a .o from .s
   7              	 * no provision for spinlock count, will spin forever if no lock available.
   8              	 **
   9              	 */
  10              	
  11              	/*
  12              	 * in C define prototype: uint32_t get_mutex(int r0, int r1);
  13              	 * in C define prototype: uint32_t get_mutex(uint32_t &mutex, uint32_t wait_count);
  14              	 
  15              	 * eabi says r0-r3 are reserved for calling and return
  16              	 * http://en.wikipedia.org/wiki/Application_binary_interface#EABI
  17              	 *  The EABI standard dictates that the ARM Stack be
  18              	 *  "Full Descending" which means that stores need to decrement beforehand and loads must increment
  19              	 *  afterward. You can use the actual addressing types "DB" and "IA" or just "FD" on the assembly i
  20              	 */
  21              	
  22              	/*
  23              	 * FOR ARM:
  24              	 * sp is r13
  25              	 * lr is r14
  26              	 * pc is r15
  27              	 */
  28              	
  29              	.text
  30              	
  31              	.code        32
  32              	
  33              	# align on 4 byte (word) boundary
  34              	.align       4
  35              	
  36              	# defining constants
  37              	.equ LOCKED   , 0
  38              	.equ INITMUTEX, 1
  39              	
  40              	# renaming registers
  41              	mutex_addr .req r0
  42              	
  43              	#inputb .req r1
  44              	#inputc .req r2
  45              	#inputd .req r3
  46              	
  47              	# r0 contains address of semaphore, need to initialize semaphore to non-zero value
  48              	# prior to using.
  49              	
  50              	.global init_mutex
  51              	init_mutex:
  52              	    # prolog
  53              	    # store multiple, decrement before. '!' says to write back new value to sp
  54 0000 F00F2DE9 	    stmdb sp!, {r4-r11}
  55              	
  56 0004 0010A0E1 	    mov r1, mutex_addr
  57 0008 0100A0E3 	    ldr r0, =INITMUTEX
ARM GAS  lpc23xx-mutex/lpc23xx-mutex.s 			page 2


  58              	
  59 000c 000081E5 	    str r0, [r1]
  60              	
  61              	    # epilog
  62              	    # load multiple, increment after. '!' says to write back new value to sp
  63 0010 F00FBDE8 	    ldmia sp!, {r4-r11}
  64              	
  65              	    # return value goes into r0, here it's zero
  66              	    # return value into r0
  67 0014 0000A0E3 	    mov r0, #0
  68              	    # lr contains address of next instruction after function
  69 0018 0EF0A0E1 	    mov pc, lr
  70              	
  71              	
  72              	# c call
  73              	.global get_mutex
  74              	get_mutex:
  75              	    # prolog
  76              	    # store multiple, decrement before. '!' says to write back new value to sp
  77 001c F00F2DE9 	    stmdb sp!, {r4-r11}
  78              	
  79 0020 0010A0E1 	    mov r1, mutex_addr
  80              	
  81              	    # address of LOCKED immediate value
  82 0024 0000A0E3 	    ldr r0, =LOCKED
  83              	
  84              	spin_lock:
  85              	    # r1 is an indirect address (note '[' and ']' 
  86 0028 900001E1 	    swp r0, r0, [r1]
  87              	    # use immediate value of LOCKED constant
  88 002c 000050E3 	    cmp r0, #LOCKED
  89 0030 FCFFFF0A 	    beq spin_lock
  90              	
  91              	    # epilog
  92              	    # load multiple, increment after. '!' says to write back new value to sp
  93 0034 F00FBDE8 	    ldmia sp!, {r4-r11}
  94              	
  95              	    # return value goes into r0, here it's zero
  96              	    # return value into r0
  97 0038 0000A0E3 	    mov r0, #0
  98              	    # lr contains address of next instruction after function
  99 003c 0EF0A0E1 	    mov pc, lr
 100              	.end
ARM GAS  lpc23xx-mutex/lpc23xx-mutex.s 			page 3


DEFINED SYMBOLS
lpc23xx-mutex/lpc23xx-mutex.s:34     .text:0000000000000000 $a
lpc23xx-mutex/lpc23xx-mutex.s:37     *ABS*:0000000000000000 LOCKED
lpc23xx-mutex/lpc23xx-mutex.s:38     *ABS*:0000000000000001 INITMUTEX
lpc23xx-mutex/lpc23xx-mutex.s:51     .text:0000000000000000 init_mutex
lpc23xx-mutex/lpc23xx-mutex.s:74     .text:000000000000001c get_mutex
lpc23xx-mutex/lpc23xx-mutex.s:84     .text:0000000000000028 spin_lock
                   .debug_aranges:000000000000000c $d

NO UNDEFINED SYMBOLS
